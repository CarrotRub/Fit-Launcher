
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Start an executable using tauri::command
 * 
 * Do not worry about using String, since the path will always be obtained by dialog through Tauri thus making it always corret for the OS.
 */
async startExecutable(path: string) : Promise<void> {
    await TAURI_INVOKE("start_executable", { path });
},
/**
 * `selected_files`: list of torrent metadata files index
 * when left empty, does nothing.
 */
async aria2StartTorrent(torrent: number[], dir: string | null, selectedFiles: number[]) : Promise<Result<string, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_start_torrent", { torrent, dir, selectedFiles }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * get total completed bytes
 */
async aria2TaskProgress(tasks: AriaTask[]) : Promise<Result<AriaTaskProgress, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_task_progress", { tasks }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.pause
 */
async aria2Pause(gid: string) : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_pause", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeDownloadedGame(gameTitle: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_downloaded_game", { gameTitle }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.unpauseAll
 */
async aria2ResumeAll() : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_resume_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGamesToDownload() : Promise<Game[]> {
    return await TAURI_INVOKE("get_games_to_download");
},
async removeCollection(collectionName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_collection", { collectionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getNewlyAddedGames() : Promise<Result<Game[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_newly_added_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSingularGameLocal(url: string) : Promise<Result<Game, ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_singular_game_local", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDiscoveryMetaPath() : Promise<string> {
    return await TAURI_INVOKE("get_discovery_meta_path");
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.pauseAll
 */
async aria2PauseAll() : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_pause_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGamehubSettingsPath() : Promise<string> {
    return await TAURI_INVOKE("get_gamehub_settings_path");
},
async getNewlyAddedGamesPath() : Promise<string> {
    return await TAURI_INVOKE("get_newly_added_games_path");
},
async getTorrentHash(torrent: number[]) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_torrent_hash", { torrent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPopularGames() : Promise<Result<Game[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_popular_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopGetGamesImages() : Promise<void> {
    await TAURI_INVOKE("stop_get_games_images");
},
/**
 * start download and receive corresponding gid's.
 * 
 * dir: output directory, leave None to use default (user Downloads)
 */
async aria2TaskSpawn(directLinks: DirectLink[], dir: string | null) : Promise<Result<AriaTaskResult[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_task_spawn", { directLinks, dir }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async aria2GlobalStat() : Promise<Result<GlobalStat, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_global_stat") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async closeSplashscreen() : Promise<void> {
    await TAURI_INVOKE("close_splashscreen");
},
async configChangeOnlyPath(downloadPath: string) : Promise<Result<null, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("config_change_only_path", { downloadPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * json_path: path to a json file, in the form like:
 * 
 * ```json
 * [
 * {
 * "name": "xxx",
 * "value": "xxx"
 * },
 * {
 * "name": "xxx",
 * "value": "xxx"
 * }
 * ]
 * ```
 * 
 * Extra fields are allowed.
 * 
 * Also, to make effect, an restart is required.
 */
async importCookiesFile(jsonPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_cookies_file", { jsonPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSingularGameInfo(gameLink: string) : Promise<Result<null, ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_singular_game_info", { gameLink }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDownloadSettings() : Promise<Result<FitLauncherConfigV2, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_download_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * ### params
 * 
 * `url`:
 * > target URL to download
 * 
 * `dir`:
 * > optional, aria2 will download the file to this directory.
 * >
 * > when not specified, aria2 will follow its startup options
 * 
 * `filename`:
 * > aria2 will ignore the filename suggestion from URL or `Content-Disposition`,
 * >
 * > instead use this filename
 * 
 * ### returns
 * 
 * `gid` of the download task.
 */
async aria2StartDownload(url: string[], dir: string | null, filename: string | null) : Promise<Result<string, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_start_download", { url, dir, filename }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getInstallationSettings() : Promise<InstallationSettings> {
    return await TAURI_INVOKE("get_installation_settings");
},
async importCookies(cookies: Cookies) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_cookies", { cookies }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDownloadedGames() : Promise<DownloadedGame[]> {
    return await TAURI_INVOKE("get_downloaded_games");
},
async getCollectionList() : Promise<GameCollection[]> {
    return await TAURI_INVOKE("get_collection_list");
},
async deleteGameFolderRecursively(folderPath: string) : Promise<Result<null, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_game_folder_recursively", { folderPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkDominantColorVec(listImages: string[]) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_dominant_color_vec", { listImages }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeGameToDownload(gameTitle: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_game_to_download", { gameTitle }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogsDirectory() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_logs_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async allowDir(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("allow_dir", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGamesImages(gameLink: string) : Promise<Result<string[], CustomError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_games_images", { gameLink }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.remove
 */
async aria2Remove(gid: string) : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_remove", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async decryptTorrentFromPaste(pasteLink: string) : Promise<Result<number[], Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("decrypt_torrent_from_paste", { pasteLink }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDnsSettingsPath() : Promise<string> {
    return await TAURI_INVOKE("get_dns_settings_path");
},
async resetGamehubSettings() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_gamehub_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearAllCache() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_all_cache") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async runAutomateSetupInstall(path: string) : Promise<Result<null, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("run_automate_setup_install", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async extractFuckingfastDdl(fuckingfastLinks: string[]) : Promise<DirectLink[]> {
    return await TAURI_INVOKE("extract_fuckingfast_ddl", { fuckingfastLinks });
},
async getRecentlyUpdatedGamesPath() : Promise<string> {
    return await TAURI_INVOKE("get_recently_updated_games_path");
},
async aria2GetListStopped() : Promise<Result<Status[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_list_stopped") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.getVersion
 */
async aria2GetVersion() : Promise<Result<Version, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_version") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDiscoveryGames() : Promise<Result<DiscoveryGame[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_discovery_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentlyUpdatedGames() : Promise<Result<Game[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recently_updated_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDatahosterLinks(gameLink: string, datahosterName: string) : Promise<string[] | null> {
    return await TAURI_INVOKE("get_datahoster_links", { gameLink, datahosterName });
},
async getDiscoveryJsonPath() : Promise<string> {
    return await TAURI_INVOKE("get_discovery_json_path");
},
async changeInstallationSettings(settings: InstallationSettings) : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_installation_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetDnsSettings() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_dns_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.tellStatus
 */
async aria2GetStatus(gid: string) : Promise<Result<Status, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_status", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPopularGamesPath() : Promise<string> {
    return await TAURI_INVOKE("get_popular_games_path");
},
async transformLegacyDownload(legacyItems: LegacyDownloadedGame[]) : Promise<DownloadedGame[]> {
    return await TAURI_INVOKE("transform_legacy_download", { legacyItems });
},
async updateDownloadedGameExecutableInfo(gameTitle: string, executableInfo: ExecutableInfo) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_downloaded_game_executable_info", { gameTitle, executableInfo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listTorrentFiles(magnet: string) : Promise<Result<FileInfo[], TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_torrent_files", { magnet }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async extractGame(dir: string) : Promise<Result<null, ExtractError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("extract_game", { dir }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getInstallationSettingsPath() : Promise<string> {
    return await TAURI_INVOKE("get_installation_settings_path");
},
async aria2GetListWaiting() : Promise<Result<Status[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_list_waiting") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async magnetToFile(magnet: string) : Promise<Result<number[], TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("magnet_to_file", { magnet }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async aria2GetListActive() : Promise<Result<Status[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_list_active") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hashUrl(url: string) : Promise<string> {
    return await TAURI_INVOKE("hash_url", { url });
},
async resetInstallationSettings() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_installation_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeGameFromCollection(gameTitle: string, collectionName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_game_from_collection", { gameTitle, collectionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async executableInfoDiscovery(pathToExe: string, pathToFolder: string) : Promise<ExecutableInfo | null> {
    return await TAURI_INVOKE("executable_info_discovery", { pathToExe, pathToFolder });
},
async addDownloadedGame(game: DownloadedGame) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_downloaded_game", { game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDnsSettings() : Promise<FitLauncherDnsConfig> {
    return await TAURI_INVOKE("get_dns_settings");
},
async changeGamehubSettings(settings: GamehubSettings) : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_gamehub_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGamehubSettings() : Promise<GamehubSettings> {
    return await TAURI_INVOKE("get_gamehub_settings");
},
async changeDnsSettings(settings: FitLauncherDnsConfig) : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_dns_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.unpause
 */
async aria2Resume(gid: string) : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_resume", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCollection(collectionName: string, games: Game[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_collection", { collectionName, games }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDownloadSettings(config: FitLauncherConfigV2) : Promise<Result<null, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_download_settings", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addGameToCollection(collectionName: string, game: Game) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_game_to_collection", { collectionName, game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type Aria2Error = "NotConfigured" | { RPCError: string }
export type AriaTask = { gid: string; filename: string }
export type AriaTaskProgress = { completed: number; download_speed: number; total_length: number; completed_length: number }
export type AriaTaskResult = { task: AriaTask | null; error: Aria2Error | null }
export type BitTorrentFileMode = "single" | "multi"
/**
 * https://aria2.github.io/manual/en/html/aria2c.html
 */
export type Bittorrent = { 
/**
 * Whether DHT is enabled for peer discovery.
 * Disabling this will reduce the ability to find peers in public swarms.
 */
enable_dht: boolean; 
/**
 * The port aria2 will listen on for incoming BitTorrent peer connections.
 * todo: Add randomization if port is blocked
 */
listen_port: number; 
/**
 * The maximum number of peers to connect to for each torrent.
 */
max_peers: number; 
/**
 * The upload/download ratio after which seeding should stop.
 * If `None`, no ratio limit is enforced (infinite seeding allowed).
 * IF `seed_time` and `seed_ratio` are set, seeding will ends when at least one of the conditions is satisfied.
 */
seed_ratio: number | null; 
/**
 * The time (in minutes) to continue seeding after the download completes.
 * If `None`, no time limit is enforced (infinite seeding allowed).
 */
seed_time: number | null }
export type BittorrentStatus = { announceList: string[][]; comment: string | null; creationDate?: string | null; mode: BitTorrentFileMode | null }
export type Connection = { max_connection_per_server: number; split: number; min_split_size: number; connect_timeout: Duration; rw_timeout: Duration }
export type Cookie = { name: string; value: string; domain: string | null; path: string | null; expires: string | null; max_age: number | null }
export type Cookies = Cookie[]
export type CreatingFileErrorStruct = { source: string; fn_name: string }
export type CustomError = { message: string }
export type DirectLink = { url: string; filename: string }
export type DiscoveryGame = { game_title: string; game_main_image: string; game_description: string; game_magnetlink: string; game_torrent_paste_link: string; game_secondary_images: string[]; game_tags: string; game_href: string }
export type DownloadedGame = { title: string; img: string; desc: string; magnetlink: string; 
/**
 * can be empty if converted from legacy,
 * 
 * or the torrent was hosted on sendfile.su
 */
pastebin: string; href: string; tag: string; executable_info: ExecutableInfo; installation_info: InstallationInfo }
export type Duration = { secs: number; nanos: number }
/**
 * Possible errors during requesting/decrypting/decoding/deserialization e.g.
 */
export type Error = { KeyLengthMismatch: number } | "ZeroIterations" | "IllFormedURL" | { Reqwest: string } | { Base58: string } | { Base64: string } | "DecompressError" | "AesGcm" | { JSONSerialize: string }
export type ExecutableInfo = { executable_path: string; executable_last_opened_date: string | null; executable_play_time: number; executable_installed_date: string | null; executable_disk_size: number }
export type ExtractError = { Io: string } | { Unrar: string } | { InstallationError: InstallationError } | "NoParentDirectory" | "NoRarFileFound"
export type File = { index: number; path: string; length: number; completedLength: number; selected: boolean; uris: Uri[] }
export type FileInfo = { file_name: string; length: number; file_index: number }
/**
 * 2. Aria2 RPC block
 * 
 */
export type FitLauncherConfigAria2 = { port: number; token: string | null; start_daemon: boolean }
export type FitLauncherConfigV2 = { general: General; limits: TransferLimits; network: Connection; bittorrent: Bittorrent; rpc: FitLauncherConfigAria2 }
export type FitLauncherDnsConfig = { system_conf: boolean; protocol: string; primary: string | null; secondary: string | null }
export type Game = { title: string; img: string; desc: string; magnetlink: string; href: string; tag: string; pastebin: string }
export type GameCollection = { name: string; games_list: Game[] }
export type GamehubSettings = { nsfw_censorship: boolean; auto_get_colors_popular_games: boolean }
export type General = { download_dir: string; concurrent_downloads?: number }
export type GlobalStat = { downloadSpeed: number; uploadSpeed: number; numActive: number; numWaiting: number; numStopped: number; numStoppedTotal: number }
export type InstallationError = { IOError: string } | "AdminModeError"
export type InstallationInfo = { output_folder: string; download_folder: string; file_list: string[] }
export type InstallationSettings = { auto_clean: boolean; auto_install: boolean; two_gb_limit: boolean; directx_install: boolean; microsoftcpp_install: boolean }
export type LegacyDownloadedGame = { torrentExternInfo: TorrentExternInfo; torrentIdx: string; torrentOutputFolder: string; torrentDownloadFolder: string; torrentFileList: string[]; checkboxesList: boolean; executableInfo: ExecutableInfo }
export type ScrapingError = { type: "articleNotFound"; data: string } | { type: "reqwestError"; data: string } | { type: "selectorError"; data: string } | { type: "fileJSONError"; data: string } | { type: "creatingFileError"; data: CreatingFileErrorStruct } | { type: "globalError"; data: string } | { type: "httpStatusCodeError"; data: string } | { type: "timeoutError"; data: string } | { type: "ioerror"; data: string } | { type: "windowError"; data: string } | { type: "cookieError"; data: string } | { type: "urlParseError"; data: string }
export type SettingsConfigurationError = { message: string }
/**
 * Full status of a task.
 * 
 * <https://aria2.github.io/manual/en/html/aria2c.html#aria2.tellStatus>
 */
export type Status = { 
/**
 * GID of the download.
 */
gid: string; status: TaskStatus; totalLength: number; completedLength: number; uploadLength: number; 
/**
 * Hexadecimal representation of the download progress.
 * 
 * The highest bit corresponds to the piece at index 0.
 * 
 * Any set bits indicate loaded pieces, while
 * unset bits indicate not yet loaded and/or missing pieces.
 * 
 * Any overflow bits at the end are set to zero.
 * 
 * When the download was not started yet,
 * this key will not be included in the response.
 */
bitfield: string | null; downloadSpeed: number; uploadSpeed: number; 
/**
 * InfoHash. BitTorrent only
 */
infoHash: string | null; numSeeders?: number | null; 
/**
 * true if the local endpoint is a seeder. Otherwise false. BitTorrent only.
 */
seeder?: boolean | null; pieceLength: number; numPieces: number; connections: number; errorCode: string | null; errorMessage: string | null; 
/**
 * List of GIDs which are generated as the result of this download.
 * 
 * For example, when aria2 downloads a Metalink file,
 * it generates downloads described in the Metalink (see the --follow-metalink option).
 * 
 * This value is useful to track auto-generated downloads.
 * 
 * If there are no such downloads, this key will not be included in the response.
 */
followedBy: string[] | null; 
/**
 * The reverse link for followedBy.
 * 
 * A download included in followedBy has this object's GID in its following value.
 */
following: string | null; 
/**
 * GID of a parent download.
 * 
 * Some downloads are a part of another download.
 * 
 * For example, if a file in a Metalink has BitTorrent resources,
 * the downloads of ".torrent" files are parts of that parent.
 * 
 * If this download has no parent, this key will not be included in the response.
 */
belongsTo: string | null; dir: string; files: File[]; bittorrent: BittorrentStatus | null; 
/**
 * The number of verified number of bytes while the files are being hash checked.
 * 
 * This key exists only when this download is being hash checked.
 */
verifiedLength?: number | null; 
/**
 * `true` if this download is waiting for the hash check in a queue.
 * 
 * This key exists only when this download is in the queue.
 */
verifyIntegrityPending?: boolean | null }
/**
 * Task status returned by `aria2.tellStatus`.
 * 
 * `Active` for currently downloading/seeding downloads.
 * 
 * `Waiting` for downloads in the queue; download is not started.
 * 
 * `Paused` for paused downloads.
 * 
 * `Error` for downloads that were stopped because of error.
 * 
 * `Complete` for stopped and completed downloads.
 * 
 * `Removed` for the downloads removed by user.
 * 
 * <https://aria2.github.io/manual/en/html/aria2c.html#aria2.tellStatus>
 */
export type TaskStatus = "active" | "waiting" | "paused" | "error" | "complete" | "removed"
export type TorrentApiError = { ApiConfigError: string } | "ConfigRetrievalError" | "AdminModeError" | { Aria2StartupError: string } | { ConfigurationError: string } | { InitError: string } | { IOError: string } | "LibrqbitError" | "MetadataError" | "TorrentNotFound" | "InvalidMagnet" | "UnexpectedTorrentState" | "ConfigChangeDuringDownload"
export type TorrentExternInfo = { title: string; img: string; desc: string; magnetlink: string; href: string; tag: string }
/**
 * In bytes/sec – `None` means unlimited
 */
export type TransferLimits = { 
/**
 * In bytes/sec – `None` means unlimited
 */
max_overall_download: number | null; 
/**
 * In bytes/sec – `None` means unlimited
 */
max_overall_upload: number | null; 
/**
 * In bytes/sec – `None` means unlimited
 */
max_download: number | null; 
/**
 * In bytes/sec – `None` means unlimited
 */
max_upload: number | null }
export type Uri = { status: UriStatus; uri: string }
export type UriStatus = "used" | "waiting"
export type Version = { enabledFeatures: string[]; version: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
