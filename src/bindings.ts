
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Clean all cache and try to delete files
 * 
 * This will not wait for real deletion, since windows file deletion happens immediately
 */
async cleanCache() : Promise<Result<null, CacheError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clean_cache") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogsDirectory() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_logs_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopGetGamesImages() : Promise<void> {
    await TAURI_INVOKE("stop_get_games_images");
},
async closeSplashscreen() : Promise<void> {
    await TAURI_INVOKE("close_splashscreen");
},
async checkDominantColorVec(listImages: string[]) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_dominant_color_vec", { listImages }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmRemove(jobId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_remove", { jobId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.getVersion
 */
async aria2GetVersion() : Promise<Result<Version, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_version") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmAllJobs() : Promise<Result<Job[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_all_jobs") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetDnsSettings() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_dns_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDownloadSettings(config: FitLauncherConfigV2) : Promise<Result<null, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_download_settings", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start an executable using tauri::command
 * 
 * Do not worry about using String, since the path will always be obtained by dialog through Tauri thus making it always corret for the OS.
 */
async startExecutable(path: string) : Promise<void> {
    await TAURI_INVOKE("start_executable", { path });
},
async addDownloadedGame(game: DownloadedGame) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_downloaded_game", { game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * `selected_files`: list of torrent metadata files index
 * when left empty, does nothing.
 */
async aria2StartTorrent(torrent: number[], dir: string | null, selectedFiles: number[]) : Promise<Result<string, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_start_torrent", { torrent, dir, selectedFiles }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.pauseAll
 */
async aria2PauseAll() : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_pause_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async panicForce() : Promise<null> {
    return await TAURI_INVOKE("panic_force");
},
async dmAddDdlJob(files: DirectLink[], target: string, game: Game) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_add_ddl_job", { files, target, game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * RD may return fewer links than files (archives)
 */
async debridGetDownloadLinks(provider: DebridProvider, torrentId: string, files: DebridFile[]) : Promise<Result<DebridDirectLink[], DebridError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("debrid_get_download_links", { provider, torrentId, files }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.tellStatus
 */
async aria2GetStatus(gid: string) : Promise<Result<Status, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_status", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openDevtools() : Promise<void> {
    await TAURI_INVOKE("open_devtools");
},
async resetInstallationSettings() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_installation_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async extractFuckingfastDdl(fuckingfastLinks: string[]) : Promise<DirectLink[]> {
    return await TAURI_INVOKE("extract_fuckingfast_ddl", { fuckingfastLinks });
},
async aria2GlobalStat() : Promise<Result<GlobalStat, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_global_stat") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.unpauseAll
 */
async aria2ResumeAll() : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_resume_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGamehubSettingsPath() : Promise<string> {
    return await TAURI_INVOKE("get_gamehub_settings_path");
},
async aria2GetListStopped() : Promise<Result<Status[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_list_stopped") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importCookies(cookies: Cookies) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_cookies", { cookies }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmAddTorrentJob(magnet: string, filesList: number[], target: string, game: Game) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_add_torrent_job", { magnet, filesList, target, game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmCleanJob(jobId: string, installationId: string) : Promise<Result<null, InstallationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_clean_job", { jobId, installationId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetGamehubSettings() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_gamehub_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmPause(jobId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_pause", { jobId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async credentialsExists(provider: DebridProvider) : Promise<Result<boolean, CredentialError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("credentials_exists", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async debridListProviders() : Promise<DebridProviderInfo[]> {
    return await TAURI_INVOKE("debrid_list_providers");
},
async getGamesToDownload() : Promise<Game[]> {
    return await TAURI_INVOKE("get_games_to_download");
},
async changeInstallationSettings(settings: InstallationSettings) : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_installation_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeDownloadedGame(gameTitle: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_downloaded_game", { gameTitle }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeCollection(collectionName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_collection", { collectionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getNewlyAddedGames() : Promise<Result<Game[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_newly_added_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentlyUpdatedGames() : Promise<Result<Game[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recently_updated_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDownloadSettings() : Promise<Result<FitLauncherConfigV2, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_download_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * get total completed bytes
 */
async aria2TaskProgress(tasks: AriaTask[]) : Promise<Result<AriaTaskProgress, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_task_progress", { tasks }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async debridGetTorrentStatus(provider: DebridProvider, torrentId: string) : Promise<Result<DebridTorrentStatus, DebridError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("debrid_get_torrent_status", { provider, torrentId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set capacity without flushing cache
 * 
 * This will literally never fail
 */
async setCapacity(newCapacity: number) : Promise<Result<null, CacheError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_capacity", { newCapacity }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCollectionList() : Promise<GameCollection[]> {
    return await TAURI_INVOKE("get_collection_list");
},
async removeGameToDownload(gameTitle: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_game_to_download", { gameTitle }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateDownloadedGameExecutableInfo(gameTitle: string, executableInfo: ExecutableInfo) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_downloaded_game_executable_info", { gameTitle, executableInfo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async credentialsList() : Promise<Result<CredentialInfo, CredentialError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("credentials_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async credentialsStatus(provider: DebridProvider) : Promise<Result<CredentialStatus, CredentialError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("credentials_status", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeGamehubSettings(settings: GamehubSettings) : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_gamehub_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearAllCache() : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_all_cache") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearGameCache() : Promise<Result<null, ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_game_cache") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async magnetToFile(magnet: string) : Promise<Result<number[], TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("magnet_to_file", { magnet }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * TODO: this isn't workin at all btw
 * 
 */
async getDatahosterLinks(gameLink: string, datahosterName: string) : Promise<string[] | null> {
    return await TAURI_INVOKE("get_datahoster_links", { gameLink, datahosterName });
},
async aria2GetAllList() : Promise<Result<Status[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_all_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDnsSettings(settings: FitLauncherDnsConfig) : Promise<Result<null, SettingsConfigurationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_dns_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async debridDeleteTorrent(provider: DebridProvider, torrentId: string) : Promise<Result<null, DebridError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("debrid_delete_torrent", { provider, torrentId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCollection(collectionName: string, games: Game[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_collection", { collectionName, games }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGamehubSettings() : Promise<GamehubSettings> {
    return await TAURI_INVOKE("get_gamehub_settings");
},
async getGamesImages(gameLink: string) : Promise<Result<string[], CustomError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_games_images", { gameLink }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async reclaimSpace(space: number) : Promise<Result<null, CacheError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reclaim_space", { space }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async credentialsGet(provider: DebridProvider) : Promise<Result<string, CredentialError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("credentials_get", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async debridGetDownloadLink(provider: DebridProvider, torrentId: string, file: DebridFile) : Promise<Result<DebridDirectLink, DebridError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("debrid_get_download_link", { provider, torrentId, file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async debridCheckCache(provider: DebridProvider, hash: string) : Promise<Result<DebridCacheStatus, DebridError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("debrid_check_cache", { provider, hash }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * ### params
 * 
 * `url`:
 * > target URL to download
 * 
 * `dir`:
 * > optional, aria2 will download the file to this directory.
 * >
 * > when not specified, aria2 will follow its startup options
 * 
 * `filename`:
 * > aria2 will ignore the filename suggestion from URL or `Content-Disposition`,
 * >
 * > instead use this filename
 * 
 * ### returns
 * 
 * `gid` of the download task.
 */
async aria2StartDownload(url: string[], dir: string | null, filename: string | null) : Promise<Result<string, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_start_download", { url, dir, filename }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPopularGames() : Promise<Result<Game[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_popular_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDiscoveryGames() : Promise<Result<Game[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_discovery_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * start download and receive corresponding gid's.
 * 
 * dir: output directory, leave None to use default (user Downloads)
 */
async aria2TaskSpawn(directLinks: DirectLink[], dir: string | null) : Promise<Result<AriaTaskResult[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_task_spawn", { directLinks, dir }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async configChangeOnlyPath(downloadPath: string) : Promise<Result<null, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("config_change_only_path", { downloadPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmSaveNow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_save_now") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDnsSettingsPath() : Promise<string> {
    return await TAURI_INVOKE("get_dns_settings_path");
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.pause
 */
async aria2Pause(gid: string) : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_pause", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getInstallationSettingsPath() : Promise<string> {
    return await TAURI_INVOKE("get_installation_settings_path");
},
/**
 * Download image, possibly add to LRUCache
 * 
 * return: data URI, for example `data:image/png;base64,...`
 */
async cachedDownloadImage(imageUrl: string) : Promise<Result<string, CacheError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cached_download_image", { imageUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async aria2GetListActive() : Promise<Result<Status[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_list_active") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.remove
 */
async aria2Remove(gid: string) : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_remove", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async aria2GetListWaiting() : Promise<Result<Status[], Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_get_list_waiting") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getInstallationSettings() : Promise<InstallationSettings> {
    return await TAURI_INVOKE("get_installation_settings");
},
async dmResume(jobId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_resume", { jobId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmLoadFromDisk() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_load_from_disk") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dmExtractAndInstall(job: Job, autoClean: boolean) : Promise<Result<string, ExtractError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_extract_and_install", { job, autoClean }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDownloadedGames() : Promise<DownloadedGame[]> {
    return await TAURI_INVOKE("get_downloaded_games");
},
/**
 * json_path: path to a json file, in the form like:
 * 
 * ```json
 * [
 * {
 * "name": "xxx",
 * "value": "xxx"
 * },
 * {
 * "name": "xxx",
 * "value": "xxx"
 * }
 * ]
 * ```
 * 
 * Extra fields are allowed.
 * 
 * Also, to make effect, an restart is required.
 */
async importCookiesFile(jsonPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_cookies_file", { jsonPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeGameFromCollection(gameTitle: string, collectionName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_game_from_collection", { gameTitle, collectionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async transformLegacyDownload(legacyItems: LegacyDownloadedGame[]) : Promise<DownloadedGame[]> {
    return await TAURI_INVOKE("transform_legacy_download", { legacyItems });
},
async getSingularGameInfo(gameLink: string) : Promise<Result<null, ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_singular_game_info", { gameLink }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listTorrentFiles(magnet: string) : Promise<Result<FileInfo[], TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_torrent_files", { magnet }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSingularGameLocal(url: string) : Promise<Result<Game, ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_singular_game_local", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async credentialsStore(provider: DebridProvider, apiKey: string) : Promise<Result<null, CredentialError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("credentials_store", { provider, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async debridAddTorrent(provider: DebridProvider, magnet: string) : Promise<Result<string, DebridError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("debrid_add_torrent", { provider, magnet }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async decryptTorrentFromPaste(pasteLink: string) : Promise<Result<number[], Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("decrypt_torrent_from_paste", { pasteLink }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteGameFolderRecursively(folderPath: string) : Promise<Result<null, TorrentApiError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_game_folder_recursively", { folderPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTorrentHash(torrent: number[]) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_torrent_hash", { torrent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async rebuildSearchIndex() : Promise<Result<null, ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("rebuild_search_index") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async credentialsRemove(provider: DebridProvider) : Promise<Result<null, CredentialError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("credentials_remove", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async debridGetTorrentInfo(provider: DebridProvider, torrentId: string) : Promise<Result<DebridTorrentInfo, DebridError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("debrid_get_torrent_info", { provider, torrentId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async querySearchIndex(query: string) : Promise<Result<SearchIndexEntry[], ScrapingError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("query_search_index", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSearchIndexPathCmd() : Promise<string> {
    return await TAURI_INVOKE("get_search_index_path_cmd");
},
async executableInfoDiscovery(pathToExe: string, pathToFolder: string) : Promise<ExecutableInfo | null> {
    return await TAURI_INVOKE("executable_info_discovery", { pathToExe, pathToFolder });
},
/**
 * unique 16 bytes text ID for a game URL
 */
async hashUrl(url: string) : Promise<number> {
    return await TAURI_INVOKE("hash_url", { url });
},
async dmRunAutomateSetupInstall(job: Job) : Promise<Result<string, InstallationError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dm_run_automate_setup_install", { job }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Finds the most likely game executable in a folder.
 * Excludes common non-game executables like installers, uninstallers, and tools.
 * Returns the path to the best candidate executable, or None if not found.
 */
async findGameExecutable(folderPath: string) : Promise<string | null> {
    return await TAURI_INVOKE("find_game_executable", { folderPath });
},
/**
 * https://aria2.github.io/manual/en/html/aria2c.html#aria2.unpause
 */
async aria2Resume(gid: string) : Promise<Result<null, Aria2Error>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("aria2_resume", { gid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDnsSettings() : Promise<FitLauncherDnsConfig> {
    return await TAURI_INVOKE("get_dns_settings");
},
async addGameToCollection(collectionName: string, game: Game) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_game_to_collection", { collectionName, game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AggregatedStatus = { total_length: number; completed_length: number; download_speed: number; upload_speed: number; per_file: Partial<{ [key in string]: FileStatus }>; state: DownloadState; progress_percentage: number }
export type Aria2Error = "NotConfigured" | { RPCError: string }
export type AriaTask = { gid: string; filename: string }
export type AriaTaskProgress = { completed: number; download_speed: number; total_length: number; completed_length: number }
export type AriaTaskResult = { task: AriaTask | null; error: Aria2Error | null }
export type BitTorrentFileMode = "single" | "multi"
/**
 * https://aria2.github.io/manual/en/html/aria2c.html
 */
export type Bittorrent = { 
/**
 * Whether DHT is enabled for peer discovery.
 * Disabling this will reduce the ability to find peers in public swarms.
 */
"enable-dht": boolean; 
/**
 * The port aria2 will listen on for incoming BitTorrent peer connections.
 * todo: Add randomization if port is blocked
 */
"listen-port": number; 
/**
 * The maximum number of peers to connect to for each torrent.
 */
"max-peers": number; 
/**
 * The upload/download ratio after which seeding should stop.
 * If `None`, no ratio limit is enforced (infinite seeding allowed).
 * IF `seed_time` and `seed_ratio` are set, seeding will ends when at least one of the conditions is satisfied.
 */
"seed-ratio": number | null; 
/**
 * The time (in minutes) to continue seeding after the download completes.
 * If `None`, no time limit is enforced (infinite seeding allowed).
 */
"seed-time": number | null }
export type BittorrentStatus = { announceList: string[][]; comment: string | null; creationDate?: string | null; mode: BitTorrentFileMode | null }
export type CacheError = { LRU: string } | { Reqwest: string } | { Kanal: string } | { IO: string } | "CacheMissing" | "MimeGuess"
export type CacheSettings = { 
/**
 * max image cache size, in bytes
 */
cache_size?: number }
export type Connection = { "max-connection-per-server": number; split: number; "min-split-size": number; "connect-timeout": Duration; "rw-timeout": Duration }
export type Cookie = { name: string; value: string; domain: string | null; path: string | null; expires: string | null; max_age: number | null }
export type Cookies = Cookie[]
export type CredentialError = { KeyringError: string } | "NotFound"
export type CredentialInfo = { configured_providers: DebridProvider[] }
export type CredentialStatus = { provider: DebridProvider; has_credential: boolean }
export type CustomError = { message: string }
export type DdlJob = { files: DirectLink[] }
export type DebridCacheStatus = { is_cached: boolean; name: string | null; size: number | null; hash: string }
export type DebridDirectLink = { url: string; filename: string; size: number }
export type DebridError = "InvalidApiKey" | "NotCached" | "RateLimited" | { ApiError: string } | { NetworkError: string } | "NotConfigured"
export type DebridFile = { id: string; name: string; short_name: string; size: number }
export type DebridProvider = "torbox" | "realdebrid" | "alldebrid"
export type DebridProviderInfo = { id: DebridProvider; name: string; description: string; website: string; color: string; is_implemented: boolean; supports_cache_check: boolean }
export type DebridTorrentInfo = { id: string; name: string; size: number; hash: string; files: DebridFile[] }
export type DebridTorrentStatus = { id: string; status: string; is_ready: boolean; progress: number; speed: number | null; seeders: number | null; name: string; size: number }
export type DirectLink = { url: string; filename: string; 
/**
 * size in bytes
 */
size: number }
export type DownloadSource = "Ddl" | "Torrent"
export type DownloadState = "active" | "paused" | "waiting" | "error" | "complete" | "installing" | "removed"
export type DownloadedGame = { title: string; img: string; 
/**
 * Game details: genres/tags, companies, languages, original size, repack size
 */
details: string; 
/**
 * Repack features section
 */
features: string; 
/**
 * Game description (the actual game info)
 */
description: string; 
/**
 * Gameplay features extracted from description
 */
gameplay_features: string; 
/**
 * Included DLCs section
 */
included_dlcs: string; magnetlink: string; href: string; tag: string; executable_info: ExecutableInfo; installation_info: InstallationInfo }
export type Duration = { secs: number; nanos: number }
/**
 * Possible errors during requesting/decrypting/decoding/deserialization e.g.
 */
export type Error = { KeyLengthMismatch: number } | "ZeroIterations" | "IllFormedURL" | { Reqwest: string } | { Base58: string } | { Base64: string } | "DecompressError" | "AesGcm" | { JSONSerialize: string }
export type ExecutableInfo = { executable_path: string; executable_last_opened_date: string | null; executable_play_time: number; executable_installed_date: string | null; executable_disk_size: number }
export type ExtractError = { Io: string } | { Unrar: string } | { InstallationError: InstallationError } | "NoParentDirectory" | "NoRarFileFound"
export type File = { index: number; path: string; length: number; completedLength: number; selected: boolean; uris: Uri[] }
export type FileAllocation = "Auto" | "Falloc" | "Prealloc" | "None"
export type FileInfo = { file_name: string; length: number; file_index: number }
export type FileStatus = { gid: string | null; status: DownloadState; total_length: number; completed_length: number; download_speed: number; upload_speed: number; files: File[]; info_hash: string | null }
/**
 * 2. Aria2 RPC block
 * 
 */
export type FitLauncherConfigAria2 = { port: number; token: string | null; start_daemon: boolean; file_allocation: FileAllocation }
export type FitLauncherConfigV2 = { general: General; cache: CacheSettings; limits: TransferLimits; network: Connection; bittorrent: Bittorrent; rpc: FitLauncherConfigAria2 }
export type FitLauncherDnsConfig = { system_conf: boolean; protocol: string; primary: string | null; secondary: string | null }
/**
 * Game data extracted from FitGirl Repacks pages.
 * 
 * This unified struct is used for all game contexts:
 * - Newly added games
 * - Popular games
 * - Recently updated games
 * - Discovery carousel games (uses secondary_images field)
 */
export type Game = { title: string; img: string; 
/**
 * Game details: genres/tags, companies, languages, original size, repack size
 */
details: string; 
/**
 * Repack features section
 */
features: string; 
/**
 * Game description (the actual game info)
 */
description: string; 
/**
 * Gameplay features extracted from description
 */
gameplay_features: string; 
/**
 * Included DLCs section
 */
included_dlcs: string; magnetlink: string; href: string; tag: string; 
/**
 * Secondary images for discovery view (empty for non-discovery games)
 */
secondary_images: string[]; pastebin_link?: string }
export type GameCollection = { name: string; games_list: Game[] }
export type GamehubSettings = { nsfw_censorship: boolean; auto_get_colors_popular_games: boolean }
export type General = { download_dir: string; concurrent_downloads?: number }
export type GlobalStat = { downloadSpeed: number; uploadSpeed: number; numActive: number; numWaiting: number; numStopped: number; numStoppedTotal: number }
export type InstallationError = { IOError: string } | "AdminModeError"
export type InstallationInfo = { output_folder: string; download_folder: string; file_list: string[] }
export type InstallationSettings = { auto_clean: boolean; auto_install: boolean; two_gb_limit: boolean; directx_install: boolean; microsoftcpp_install: boolean }
export type Job = { id: string; metadata: JobMetadata; game: Game; job_path: string; source: DownloadSource; gids: string[]; ddl: DdlJob | null; torrent: TorrentJob | null; state: DownloadState; status: AggregatedStatus | null }
export type JobMetadata = { game_title: string; target_path: string; created_at: string; updated_at: string }
export type LegacyDownloadedGame = { torrentExternInfo: TorrentExternInfo; torrentIdx: string; torrentOutputFolder: string; torrentDownloadFolder: string; torrentFileList: string[]; checkboxesList: boolean; executableInfo: ExecutableInfo }
export type ScrapingError = { type: "articleNotFound"; data: string } | { type: "reqwestError"; data: string } | { type: "selectorError"; data: string } | { type: "jsonError"; data: string } | { type: "generalError"; data: string } | { type: "httpStatusCodeError"; data: string } | { type: "timeoutError"; data: string } | { type: "ioerror"; data: string } | { type: "windowError"; data: string } | { type: "cookieError"; data: string } | { type: "urlParseError"; data: string } | { type: "regexError"; data: string } | { type: "semaphoreError"; data: string }
export type SearchIndexEntry = { slug: string; title: string; href: string }
export type SettingsConfigurationError = { message: string }
/**
 * Full status of a task.
 * 
 * <https://aria2.github.io/manual/en/html/aria2c.html#aria2.tellStatus>
 */
export type Status = { 
/**
 * GID of the download.
 */
gid: string; status: TaskStatus; totalLength: number; completedLength: number; uploadLength: number; 
/**
 * Hexadecimal representation of the download progress.
 * 
 * The highest bit corresponds to the piece at index 0.
 * 
 * Any set bits indicate loaded pieces, while
 * unset bits indicate not yet loaded and/or missing pieces.
 * 
 * Any overflow bits at the end are set to zero.
 * 
 * When the download was not started yet,
 * this key will not be included in the response.
 */
bitfield: string | null; downloadSpeed: number; uploadSpeed: number; 
/**
 * InfoHash. BitTorrent only
 */
infoHash: string | null; numSeeders?: number | null; 
/**
 * true if the local endpoint is a seeder. Otherwise false. BitTorrent only.
 */
seeder?: boolean | null; pieceLength: number; numPieces: number; connections: number; errorCode: string | null; errorMessage: string | null; 
/**
 * List of GIDs which are generated as the result of this download.
 * 
 * For example, when aria2 downloads a Metalink file,
 * it generates downloads described in the Metalink (see the --follow-metalink option).
 * 
 * This value is useful to track auto-generated downloads.
 * 
 * If there are no such downloads, this key will not be included in the response.
 */
followedBy: string[] | null; 
/**
 * The reverse link for followedBy.
 * 
 * A download included in followedBy has this object's GID in its following value.
 */
following: string | null; 
/**
 * GID of a parent download.
 * 
 * Some downloads are a part of another download.
 * 
 * For example, if a file in a Metalink has BitTorrent resources,
 * the downloads of ".torrent" files are parts of that parent.
 * 
 * If this download has no parent, this key will not be included in the response.
 */
belongsTo: string | null; dir: string; files: File[]; bittorrent: BittorrentStatus | null; 
/**
 * The number of verified number of bytes while the files are being hash checked.
 * 
 * This key exists only when this download is being hash checked.
 */
verifiedLength?: number | null; 
/**
 * `true` if this download is waiting for the hash check in a queue.
 * 
 * This key exists only when this download is in the queue.
 */
verifyIntegrityPending?: boolean | null }
/**
 * Task status returned by `aria2.tellStatus`.
 * 
 * `Active` for currently downloading/seeding downloads.
 * 
 * `Waiting` for downloads in the queue; download is not started.
 * 
 * `Paused` for paused downloads.
 * 
 * `Error` for downloads that were stopped because of error.
 * 
 * `Complete` for stopped and completed downloads.
 * 
 * `Removed` for the downloads removed by user.
 * 
 * <https://aria2.github.io/manual/en/html/aria2c.html#aria2.tellStatus>
 */
export type TaskStatus = "active" | "waiting" | "paused" | "error" | "complete" | "removed"
export type TorrentApiError = { ApiConfigError: string } | "ConfigRetrievalError" | "AdminModeError" | { Aria2StartupError: string } | { ConfigurationError: string } | { InitError: string } | { IOError: string } | "LibrqbitError" | "MetadataError" | "TorrentNotFound" | "InvalidMagnet" | "UnexpectedTorrentState" | "ConfigChangeDuringDownload"
export type TorrentExternInfo = { title: string; img: string; desc: string; magnetlink: string; href: string; tag: string }
export type TorrentJob = { torrent_bytes: number[]; file_indices: number[]; torrent_files: FileInfo[]; info_hash: string; magnet: string }
/**
 * In bytes/sec – `None` means unlimited
 */
export type TransferLimits = { 
/**
 * In bytes/sec – `None` means unlimited
 */
"max-overall-download": number | null; 
/**
 * In bytes/sec – `None` means unlimited
 */
"max-overall-upload": number | null; 
/**
 * In bytes/sec – `None` means unlimited
 */
"max-download": number | null; 
/**
 * In bytes/sec – `None` means unlimited
 */
"max-upload": number | null }
export type Uri = { status: UriStatus; uri: string }
export type UriStatus = "used" | "waiting"
export type Version = { enabledFeatures: string[]; version: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
